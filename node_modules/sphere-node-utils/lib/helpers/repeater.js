var Promise, Repeater, _, debug;

debug = require('debug')('repeater');

_ = require('underscore');

Promise = require('bluebird');


/**
 * A new Repeater instance
 * @class Repeater
 *
 * A Repeater allows to execute a promise and recover from it in case of errors,
 * by retrying to execute the task for a certain number of times before giving up.
 */

Repeater = (function() {

  /**
   * Initialize the class
   * @constructor
   * @param {Object} [options] A JSON object containing configuration options
   * - `attempts` how many times it should retry
   * - `timeout` delay before retrying
   * - `timeoutType`
   *   - `c`: constant delay
   *   - `v`: variable delay (grows with attempts count with a random component)
   */
  function Repeater(options) {
    if (options == null) {
      options = {};
    }
    this._options = _.defaults(options, {
      attempts: 10,
      timeout: 100,
      timeoutType: 'c'
    });
    debug('new Repeater with options: %j', this._options);
  }


  /**
   * Resolves the {Promise} defined in the `task` function, allowing to
   * recover it from arbitrary errors via the `recover` function.
   * @param  {Promise} task The promise that needs to be resolved
   * @param  {Function} recover A function that is called with the `error` object
   *                            if the `task` promise failed, returning a new {Promise}
   * @return {Promise} A Promise, fulfilled with the resolved `task`, or rejected with an error
   */

  Repeater.prototype.execute = function(task, recover) {
    return new Promise((function(_this) {
      return function(resolve, reject) {
        return _this._repeat({
          task: task,
          recover: recover,
          defer: {
            resolve: resolve,
            reject: reject
          },
          remainingAttempts: _this._options.attempts,
          lastError: null
        });
      };
    })(this));
  };


  /**
   * @private
   * The function that handles the retrying, calling itself recursively
   * @param  {Object} opts The options used for retrying the {Promise}
   */

  Repeater.prototype._repeat = function(opts) {
    var defer, lastError, recover, remainingAttempts, task;
    task = opts.task, recover = opts.recover, defer = opts.defer, remainingAttempts = opts.remainingAttempts, lastError = opts.lastError;
    debug('(re)-trying task, %d remaining attempts', remainingAttempts);
    if (remainingAttempts === 0) {
      return defer.reject({
        message: "Failed to retry the task after " + this._options.attempts + " attempts.",
        error: lastError
      });
    } else {
      return task().then(function(r) {
        return defer.resolve(r);
      })["catch"]((function(_this) {
        return function(e) {
          debug('uh got an error, about to recover: %o', e);
          return recover(e).then(function(newTask) {
            var recoverDelay;
            recoverDelay = _this._calculateDelay(remainingAttempts);
            debug('will recover after %d delay', recoverDelay);
            return Promise.delay(recoverDelay).then(function() {
              debug('about to recover');
              return _this._repeat({
                task: newTask || task,
                recover: recover,
                defer: defer,
                remainingAttempts: remainingAttempts - 1,
                lastError: e
              });
            });
          })["catch"](function(e) {
            return defer.reject(e);
          });
        };
      })(this)).done();
    }
  };


  /**
   * @private
   * Calculate the delay between attempts based on the `timeoutType`
   * @param  {Number} attemptsLeft How many attempts are left before giving up
   * @return {Number} The calculated delay
   */

  Repeater.prototype._calculateDelay = function(attemptsLeft) {
    var tried;
    switch (this._options.timeoutType) {
      case 'v':
        tried = this._options.attempts - attemptsLeft - 1;
        if (tried < 0) {
          tried = 0;
        }
        return (this._options.timeout * tried) + _.random(50, this._options.timeout);
      default:
        return this._options.timeout;
    }
  };

  return Repeater;

})();

module.exports = Repeater;
