var ProjectCredentialsConfig, Promise, _, _s, csv, fs, fsExistsAsync;

_ = require('underscore');

_s = require('underscore.string');

csv = require('csv');

Promise = require('bluebird');

fs = Promise.promisifyAll(require('fs'));

fsExistsAsync = function(path) {
  return new Promise(function(resolve, reject) {
    return fs.exists(path, function(exists) {
      if (exists) {
        return resolve(true);
      } else {
        return resolve(false);
      }
    });
  });
};


/**
 * Provides sphere credentials based on the project key.
 *
 * Following files are used to store the credentials and would be searched (descending priority):
 *
 * ./.sphere-project-credentials
 * ./.sphere-project-credentials.json
 * ~/.sphere-project-credentials
 * ~/.sphere-project-credentials.json
 * /etc/sphere-project-credentials
 * /etc/sphere-project-credentials.json
 */

ProjectCredentialsConfig = (function() {
  ProjectCredentialsConfig.create = function(options) {
    if (options == null) {
      options = {};
    }
    return (new ProjectCredentialsConfig(options))._init();
  };

  function ProjectCredentialsConfig(options) {
    if (options == null) {
      options = {};
    }
    this._baseName = options.baseName || 'sphere-project-credentials';
    this._lookupFiles = options.lookupFiles || ["./." + this._baseName, "./." + this._baseName + ".json", "~/." + this._baseName, "~/." + this._baseName + ".json", "/etc/" + this._baseName, "/etc/" + this._baseName + ".json"];
  }

  ProjectCredentialsConfig.prototype._init = function() {
    return this._loadCredentials().then((function(_this) {
      return function(res) {
        _this._credentials = res;
        return Promise.resolve(_this);
      };
    })(this));
  };

  ProjectCredentialsConfig.prototype._loadCredentials = function() {
    var configsP;
    configsP = _.map(this._lookupFiles, (function(_this) {
      return function(path) {
        var normalizedPath;
        normalizedPath = _this._normalizePath(path);
        return fsExistsAsync(normalizedPath).then(function(exists) {
          if (exists) {
            return fs.readFileAsync(normalizedPath, {
              encoding: 'utf-8'
            }).then(function(contents) {
              if (_s.endsWith(normalizedPath, '.json')) {
                return _this._readJsonConfig("" + contents);
              } else {
                return _this._readCsvConfig("" + contents);
              }
            });
          } else {
            return Promise.resolve({});
          }
        });
      };
    })(this));
    configsP.push(this._getEnvCredetials());
    return Promise.all(configsP).then(function(configs) {
      return _.reduce(configs.reverse(), (function(acc, c) {
        return _.extend(acc, c);
      }), {});
    });
  };

  ProjectCredentialsConfig.prototype._readJsonConfig = function(contents) {
    var config;
    config = JSON.parse(contents);
    _.each(_.keys(config), function(key) {
      return config[key].project_key = key;
    });
    return Promise.resolve(config);
  };

  ProjectCredentialsConfig.prototype._readCsvConfig = function(csvText) {
    return new Promise(function(resolve, reject) {
      return csv().from(csvText, {
        delimiter: ":"
      }).to.array(function(data) {
        var dataJson;
        dataJson = _.map(data, function(row) {
          return {
            project_key: row[0],
            client_id: row[1],
            client_secret: row[2]
          };
        });
        return resolve(_.reduce(dataJson, function(acc, json) {
          acc[json.project_key] = json;
          return acc;
        }, {}));
      }).on('error', function(error) {
        return reject(error);
      });
    });
  };

  ProjectCredentialsConfig.prototype._getEnvCredetials = function() {
    var envVars, obj;
    envVars = _.pick(process.env, 'SPHERE_PROJECT_KEY', 'SPHERE_CLIENT_ID', 'SPHERE_CLIENT_SECRET');
    if (_.values(envVars).length === 3) {
      return (
        obj = {},
        obj["" + envVars.SPHERE_PROJECT_KEY] = {
          project_key: envVars.SPHERE_PROJECT_KEY,
          client_id: envVars.SPHERE_CLIENT_ID,
          client_secret: envVars.SPHERE_CLIENT_SECRET
        },
        obj
      );
    }
  };


  /**
   * Returns project credentials for the project key.
   *
   * @param {String} key The project key
   * @returns Credentials have following structure: {project_key: 'key', client_id: 'foo', client_secret: 'bar'}
   */

  ProjectCredentialsConfig.prototype.forProjectKey = function(key) {
    return this.enrichCredentials({
      project_key: key
    });
  };


  /**
   * Enriches project credentials if client_id or client_secret are missing.
   *
   * @returns Credentials have following structure: {project_key: 'key', client_id: 'foo', client_secret: 'bar'}
   */

  ProjectCredentialsConfig.prototype.enrichCredentials = function(credentials) {
    if ((credentials.client_id != null) && (credentials.client_secret != null)) {
      return credentials;
    } else {
      if (this._credentials[credentials.project_key] != null) {
        return this._credentials[credentials.project_key];
      } else {
        throw new Error("Can't find credentials for project '" + credentials.project_key + "'.");
      }
    }
  };

  ProjectCredentialsConfig.prototype._normalizePath = function(path) {
    if ((path == null) || _s.isBlank(path)) {
      throw new Error('Path is empty!');
    }
    return path.replace("~", this._getUserHome());
  };

  ProjectCredentialsConfig.prototype._getUserHome = function() {
    return process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE;
  };

  return ProjectCredentialsConfig;

})();

module.exports = ProjectCredentialsConfig;
