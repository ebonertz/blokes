var Connection, Promise, Sftp, _, debug, uniqueId;

debug = require('debug')('sftp');

_ = require('underscore');

Promise = require('bluebird');

Connection = require('ssh2');

uniqueId = function(prefix) {
  return _.uniqueId("" + prefix + (new Date().getTime()) + "_");
};

Sftp = (function() {
  function Sftp(_options) {
    this._options = _options != null ? _options : {};
  }


  /**
   * Get directory entries.
   * @param {Object} sftp SFTP handle
   * @param {String} dirName Directory to get the entries from
   * @return {Promise} A promise, fulfilled with an {Array} or rejected with an error
   */

  Sftp.prototype.listFiles = function(sftp, dirName) {
    return new Promise(function(resolve, reject) {
      return sftp.readdir(dirName, function(err, list) {
        if (err) {
          return reject(err);
        } else {
          return resolve(list);
        }
      });
    });
  };


  /**
   * {@link https://github.com/mscdex/ssh2#stats}
   * Get directory statistics (useful to check if file is directory or file)
   * @param {Object} sftp SFTP handle
   * @param {String} path Path to the file where to get the stats from
   * @return {Promise} A promise, fulfilled with an {Array} or rejected with an error
   */

  Sftp.prototype.stats = function(sftp, path) {
    return new Promise(function(resolve, reject) {
      return sftp.stat(path, function(err, stats) {
        if (err) {
          return reject(err);
        } else {
          return resolve(stats);
        }
      });
    });
  };

  Sftp.prototype.readFile = function(fileName) {};

  Sftp.prototype.saveFile = function(path, fileName, content) {};


  /**
   * Download a file.
   * @param {Object} sftp SFTP handle
   * @param {String} remotePath Path of the remote file
   * @param {String} localPath Download file to this path
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with an error
   */

  Sftp.prototype.getFile = function(sftp, remotePath, localPath) {
    return new Promise(function(resolve, reject) {
      return sftp.fastGet(remotePath, localPath, function(err) {
        if (err) {
          return reject(err);
        } else {
          return resolve();
        }
      });
    });
  };


  /**
   * Upload a file.
   * @param {Object} sftp SFTP handle
   * @param {String} localPath Upload file to this path
   * @param {String} remotePath Path of the remote file
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with an error
   */

  Sftp.prototype.putFile = function(sftp, localPath, remotePath) {
    return new Promise(function(resolve, reject) {
      return sftp.fastPut(localPath, remotePath, function(err) {
        if (err) {
          return reject(err);
        } else {
          return resolve();
        }
      });
    });
  };


  /**
   * Upload a file safely by temporarly upload it to a tmp folder, moving it then into the
   * given target path to assure that it's there.
   * @param {Object} sftp SFTP handle
   * @param {String} localPath Upload file to this path
   * @param {String} remotePath Path of the remote file
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with an error
   */

  Sftp.prototype.safePutFile = function(sftp, localPath, remotePath, forceOverwrite) {
    var canUpload, tmpName;
    if (forceOverwrite == null) {
      forceOverwrite = true;
    }
    tmpName = remotePath + "_" + (uniqueId('tmp'));
    debug("About to upload file " + localPath);
    canUpload = (function(_this) {
      return function(fileName) {
        if (forceOverwrite) {
          debug('Force overwrite is true, proceed with upload');
          return Promise.resolve();
        } else {
          debug("Force overwrite is false, checking if " + fileName + " exists");
          return _this.stats(sftp, fileName).then(function(stat) {
            if (stat.isFile()) {
              return Promise.reject("Uploading file " + fileName + " already exists on the remote server and cannot proceed unless I'm being forced to");
            } else {
              debug("File " + fileName + " doesn't appear to be a file, proceeding with upload");
              return Promise.resolve();
            }
          })["catch"](function() {
            debug("File " + fileName + " not found, proceeding with upload");
            return Promise.resolve();
          });
        }
      };
    })(this);
    return canUpload(tmpName).then((function(_this) {
      return function() {
        return _this.putFile(sftp, localPath, tmpName);
      };
    })(this)).then((function(_this) {
      return function() {
        debug("File uploaded as " + tmpName);
        return _this.stats(sftp, tmpName);
      };
    })(this)).then((function(_this) {
      return function(stat) {
        if (stat.isFile()) {
          debug("File check successful, about to rename it");
          return _this.safeRenameFile(sftp, tmpName, remotePath);
        } else {
          debug("File check failed, about to cleanup " + tmpName);
          return _this.removeFile(sftp, tmpName).then(function() {
            return Promise.reject('File upload check failed');
          });
        }
      };
    })(this));
  };


  /**
   * Rename a remote resource.
   * @param {Object} sftp SFTP handle
   * @param {String} srcPath Source path of the remote resource
   * @param {String} destPath Destination path of the remote resource
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with an error
   */

  Sftp.prototype.renameFile = function(sftp, srcPath, destPath) {
    return new Promise(function(resolve, reject) {
      return sftp.rename(srcPath, destPath, function(err) {
        if (err) {
          return reject(err);
        } else {
          return resolve();
        }
      });
    });
  };


  /**
   * Rename a remote resource safely, by checking if it's there first and remove it if so.
   * @param {Object} sftp SFTP handle
   * @param {String} srcPath Source path of the remote resource
   * @param {String} destPath Destination path of the remote resource
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with an error
   */

  Sftp.prototype.safeRenameFile = function(sftp, srcPath, destPath) {

    /* WORKAROUND
    Unfortunately, rename will fail if there is already an existing file with the same name.
    To avoid that, we should remove first the old file, then rename the new one
     */
    debug("About to safe rename the file " + srcPath + " to " + destPath);
    return this.stats(sftp, destPath).then((function(_this) {
      return function(stat) {
        debug("File " + destPath + " already exist, about to remove it before rename it");
        if (stat.isFile()) {
          return _this.removeFile(sftp, destPath).then(function() {
            debug("File " + destPath + " removed, about to rename it");
            return _this.renameFile(sftp, srcPath, destPath).then(function() {
              return Promise.resolve();
            })["catch"](function(err) {
              debug("Failed to rename file " + destPath + " during safeRename");
              return Promise.reject(err);
            });
          })["catch"](function(err) {
            debug("Failed to remove file " + destPath + " during safeRename");
            return Promise.reject(err);
          });
        } else {
          return Promise.reject("The resource at " + destPath + " already exist and it doesn't appear to be a file. Please check that what you want to rename is a file.");
        }
      };
    })(this))["catch"]((function(_this) {
      return function(err) {
        if (err.message === 'No such file') {
          debug("File " + destPath + " doesn't exist, about to rename it");
          return _this.renameFile(sftp, srcPath, destPath);
        } else {
          return Promise.reject(err);
        }
      };
    })(this));
  };


  /**
   * Remove remote file
   * @param {Object} sftp SFTP handle
   * @param {String} path Path to the remote file
   * @return {Promise} A promise, fulfilled with an {Array} or rejected with an error
   */

  Sftp.prototype.removeFile = function(sftp, path) {
    return new Promise(function(resolve, reject) {
      return sftp.unlink(path, function(err) {
        if (err) {
          return reject(err);
        } else {
          return resolve();
        }
      });
    });
  };


  /**
   * Starts a SFTP session.
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with an error
   */

  Sftp.prototype.openSftp = function() {
    return new Promise((function(_this) {
      return function(resolve, reject) {
        var connectOpts;
        _this.conn = new Connection();
        _this.conn.on('ready', function() {
          debug('Connection :: ready');
          return _this.conn.sftp(function(err, sftp) {
            if (err) {
              return reject(err);
            } else {
              sftp.on('end', function() {
                return debug('SFTP :: end');
              });
              return resolve(sftp);
            }
          });
        });
        _this.conn.on('error', function(err) {
          debug(err, 'Connection :: error');
          return reject(err);
        });
        _this.conn.on('close', function(hadError) {
          debug("Connection :: close - had error: " + hadError);
          if (hadError) {
            return reject('Error on closing SFTP connection');
          }
        });
        _this.conn.on('end', function() {
          return debug('Connection :: end');
        });
        connectOpts = {
          host: _this._options.host,
          username: _this._options.username,
          password: _this._options.password
        };
        if (_this._options.port) {
          connectOpts['port'] = _this._options.port;
        }
        if (_this._options.debug) {
          connectOpts['debug'] = function(msg) {
            return debug(msg);
          };
        }
        return _this.conn.connect(connectOpts);
      };
    })(this));
  };


  /**
   * Close SFTP session and underlying connection.
   * @param {Object} sftp SFTP handle
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with an error
   */

  Sftp.prototype.close = function(sftp) {
    if (sftp) {
      sftp.end();
    }
    return this.conn.end();
  };


  /**
   * Download all files from a given remote folder (exclude '.', '..' and directories)
   * @param {Object} sftp SFTP handle
   * @param {String} tmpFolder Local tmp folder path where to save the files to
   * @param {String} remoteFolder Remote path folder where to download the files from
   * @param {String} [fileRegex] A RegExp to be applied when filtering files
   * @param {Number} [maxConcurrency=3] maximum number of concurrent downloads from SFTP
   * @return {Promise} A promise, fulfilled with an {Object} or rejected with an error
   */

  Sftp.prototype.downloadAllFiles = function(sftp, tmpFolder, remoteFolder, fileRegex, maxConcurrency) {
    if (fileRegex == null) {
      fileRegex = '';
    }
    if (maxConcurrency == null) {
      maxConcurrency = 3;
    }
    return new Promise((function(_this) {
      return function(resolve, reject) {
        return _this.listFiles(sftp, remoteFolder).then(function(files) {
          var filteredFiles, regex;
          debug(files, 'List of files');
          regex = new RegExp(fileRegex);
          filteredFiles = _.filter(files, function(f) {
            switch (f.filename) {
              case '.':
              case '..':
                return false;
              default:
                return regex.test(f.filename);
            }
          });
          return Promise.map(filteredFiles, (function(f) {
            return _this.stats(sftp, remoteFolder + "/" + f.filename);
          }), {
            concurrency: maxConcurrency
          }).then(function(stats) {
            var filesOnly;
            filesOnly = [];
            _.each(filteredFiles, function(f, i) {
              if (stats[i].isFile()) {
                return filesOnly.push(f);
              }
            });
            debug(filesOnly, "About to download");
            return Promise.map(filesOnly, (function(f) {
              return _this.getFile(sftp, remoteFolder + "/" + f.filename, tmpFolder + "/" + f.filename);
            }), {
              concurrency: maxConcurrency
            });
          }).then(function() {
            return resolve();
          });
        })["catch"](function(error) {
          return reject(error);
        });
      };
    })(this));
  };

  return Sftp;

})();

module.exports = Sftp;
