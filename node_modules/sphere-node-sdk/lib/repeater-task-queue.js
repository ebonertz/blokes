/* ===========================================================
# sphere-node-sdk - v1.17.0
# ==============================================================
# Copyright (c) 2016 SPHERE.IOâ„¢
# Licensed .
#
#    
*/
var Promise, Repeater, RepeaterTaskQueue, TaskQueue, _, retryKeywords,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Repeater = require('sphere-node-utils').Repeater;

Promise = require('bluebird');

TaskQueue = require('./task-queue');

_ = require('underscore');

retryKeywords = ['ETIMEDOUT', 'socket hang up', 'write EPROTO', 'Retry later', 'I am the LoadBalancer of', 'Gateway Timeout', 'Bad Gateway', 'EAI_AGAIN', 'ESOCKETTIMEDOUT', 'Oops. This shouldn\'t happen', 'InternalServerError: Undefined', 'Temporary overloading', 'read ECONNRESET', 'getaddrinfo ENOTFOUND', 'Cannot commit on stream id'];

RepeaterTaskQueue = (function(superClass) {
  extend(RepeaterTaskQueue, superClass);

  function RepeaterTaskQueue(options, repeaterOptions) {
    this._startTask = bind(this._startTask, this);
    RepeaterTaskQueue.__super__.constructor.call(this, options);
    repeaterOptions = _.defaults(repeaterOptions, {
      attempts: 50,
      timeout: 200,
      timeoutType: 'v',
      retryKeywords: retryKeywords
    });
    this.repeaterOptions = repeaterOptions;
  }

  RepeaterTaskQueue.prototype._startTask = function(task) {
    var repeater, toRepeat;
    this._activeCount += 1;
    repeater = new Repeater(this.repeaterOptions);
    toRepeat = repeater.execute(task.fn, (function(_this) {
      return function(err) {
        if (_this._shouldRetry(err)) {
          return Promise.resolve();
        } else {
          return Promise.reject(err);
        }
      };
    })(this));
    return toRepeat.then(function(res) {
      task.resolve(res);
    })["catch"](function(err) {
      task.reject(err);
    })["finally"]((function(_this) {
      return function() {
        _this._activeCount -= 1;
        return _this._maybeExecute();
      };
    })(this)).done();
  };

  RepeaterTaskQueue.prototype._shouldRetry = function(error) {
    var ref, ref1;
    return (error != null ? (ref = error.code) != null ? ref.toString().startsWith('5') : void 0 : void 0) || (error != null ? (ref1 = error.statusCode) != null ? ref1.toString().startsWith('5') : void 0 : void 0) || this.repeaterOptions.retryKeywords.some(function(keyword) {
      return JSON.stringify(error).toUpperCase().includes(keyword.toUpperCase());
    });
  };

  return RepeaterTaskQueue;

})(TaskQueue);

module.exports = RepeaterTaskQueue;
